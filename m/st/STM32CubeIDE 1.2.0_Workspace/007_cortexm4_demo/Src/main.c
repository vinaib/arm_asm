/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include<stdio.h>
#include<stdint.h>

//Block 8
#define IRQNO_TIMER2 28
#define IRQNO_I2C1	 31

uint32_t *pNVIC_IPRBase = (uint32_t*)0xE000E400;
uint32_t *pNVIC_ISERBase = (uint32_t*)0xE000E100;
uint32_t *pNVIC_ISPRBase = (uint32_t*)0xE000E200;

void configure_priority_for_irqs(uint8_t irqno, uint8_t priority_value)
{
	//find our iprx
	uint8_t iprx = irqno/4;
	uint32_t *ipr = pNVIC_IPRBase + iprx;

	//position in iprx
	uint8_t pos = (irqno%4) * 8;

	//configure the priority
	//stm32 16 priority levels
	//0x00 0x10 0x20 0x30 0x40 0x50 0x60 0x70 0x80 0x90 0xa0 0xb0 0xc0 0xd0 0xe0 0xf0
	*ipr &= ~(0xFF << pos);	//clear
	*ipr |= (priority_value << pos);

}

// Block 7
#define USART3_IRQNO 39

//Block 6
#define SRAM_START 	0X20000000
#define SRAM_SIZE	(128 * 1024)
#define SRAM_END	((SRAM_START) + (SRAM_SIZE))

#define STACK_START	SRAM_END

#define STACK_MSP_START	STACK_START
#define STACK_MSP_END	((STACK_MSP_START) + 512)
#define STACK_PSP_START STACK_MSP_END
#define STACK_PSP_END	((STACK_PSP_START) + 512)

/* .equ label value*/

int fun_add(int a, int b, int c, int d)
{
	return (a+b+c+d);
}

__attribute__((naked)) void change_sp_to_psp(void)
{
	//initialize psp with initial value
	// we cannot use C macros in assembly instructions
	//__asm volatile("LDR R0, =STACK_PSP_START");
	__asm volatile(".equ SRAM_END, (0x20000000 + (128 * 1024))");
	__asm volatile(".equ PSP_START, (SRAM_END - 512)");
	__asm volatile("LDR R0, =PSP_START");
	__asm volatile("MSR PSP, R0");

	//switch sp to PSP, by set SPSEL bit in CONTROL
	__asm volatile("mov r0, #0x02");
	__asm volatile("msr control, r0");

	__asm volatile("bx lr");
}

void generate_exception(void)
{
	__asm volatile("svc #0x2");
}

//Block 5
#define ALIAS_BASE 		0x22000000U
#define BITBAND_BASE 	0x20000000U

//Block 4
void change_access_level_unpriv(void)
{
	//read
	__asm volatile("mrs r0, CONTROL");
	//modify
	__asm volatile("orr r0, r0, #1");
	//write
	__asm volatile("msr CONTROL, r0");
}

void generate_interrupt(void)
{
	/* To access the processor internal peripherals, thread need privilege access level(PAL).
	 * With out PAL, if thread access these registers processor issues processor fault exceptions.
	 **/

	uint32_t *pSTIR = (uint32_t*)0xE000EF00;
	uint32_t *pISER0 = (uint32_t*)0xE000E100;

	//enable IRQ3 interrupt
	*pISER0 |= (1 << 3);

	//generate an interrupt from software for IRQ3
	*pSTIR = (3 & 0x1FF);
}

/* This function executes in thread mode + PRIV access level of the processor */
int main(void)
{
/*	//Block 1
 * printf("In thread mode: before interrupt\n");

	generate_interrupt();

	printf("In thread mode: after interrupt\n");*/

/*	//Block 2
 * __asm volatile ("ldr r1, =#0x20001000\r\n");
	__asm volatile ("ldr r2, =#0x20001004\r\n");
	__asm volatile ("ldr r0, [r1]\r\n");
	__asm volatile ("ldr r1, [r2]\r\n");
	__asm volatile ("add r0, r0, r1\r\n");
	__asm volatile ("str r0, [r2]\r\n");*/

/*	//Block 3
 * int val = 50;
	__asm volatile ("mov r0, %0"::"r"(val));

	int control_reg;
	__asm volatile ("mrs %0,APSR" :"=r"(control_reg)::);

	int var1 = 10, var2;
	__asm ("mov %0, %1":"=r"(var2):"r"(var1):);

	int p1, *p2 = (int *)0x20000008;
	__asm ("ldr %0, [%1]"
			:"=r"(p1)
			:"r"(p2)
			:);

	printf("control_reg 0x%x var2 %d p1 %d\n", control_reg, var2, p1);*/

	//Block 4
/*
	printf("In thread mode: before interrupt\n");

	change_access_level_unpriv();

	generate_interrupt();

	printf("In thread mode: after interrupt\n");
*/
	//Block 5 Bit banding address
/*	uint8_t *ptr = (uint8_t*)0x20000200;

	*ptr = 0xff;

	//normal method: clearing the 7th bit
	*ptr &= ~(1 << 7);

	//reset to 0xff
	*ptr = 0xff;

	//bit band method
	uint8_t *alias_addr = (uint8_t*)(ALIAS_BASE + 32 *(ptr - (uint8_t*)BITBAND_BASE)) + (7 * 4);
	*alias_addr = 0;*/

	//Block 6: stack: MSP and PSP
/*	int ret;

	change_sp_to_psp();

	ret = fun_add(1,4,5,6);

	printf("result %d\n", ret);

	generate_exception();*/

	// Block 7: USART3 interrupt handling, by setting the NVIC interrupt set enable register manually.
	// This manual set is for to demo only. Ideally this pending register bit is set by hardware.
	// IRQ number of USART3 is 39, refer rm
/*	uint32_t *pISPR1 = (uint32_t*)0xE000E204;

	// Manually pend the USART3
	*pISPR1 |= (1 << (USART3_IRQNO % 32));

	//2. Enable the USART3 IRQ number in NVIC
	uint32_t *pISER1 = (uint32_t*)0xE000E104;
	*pISER1 |= (1 << (USART3_IRQNO % 32));*/

	//Block 8
	/*
	 * Demo on interrupt Priority
	 */
	//1. configure the priority for the peripherals
	configure_priority_for_irqs(IRQNO_TIMER2, 0x80);
	configure_priority_for_irqs(IRQNO_I2C1, 0x80);	//try with priority 0x80, equal to timer2
	configure_priority_for_irqs(IRQNO_I2C1, 0x70);  // try with priority 0x70, higher than timer2,
												    // which means i2c1 interrupt will preempt timer2 interrupt

	//2. set the interrupt pending bit in the NVIC PR
	*pNVIC_ISPRBase |= (1 << IRQNO_TIMER2);

	//3. Enable the IRQs in NVIC Interrupt Set Enable Register(ISER)
	*pNVIC_ISERBase |= (1 << IRQNO_I2C1);
	*pNVIC_ISERBase |= (1 << IRQNO_TIMER2);


	for(;;);
}


void RTC_WKUP_IRQHandler(void)
{
	printf("In handler mode ISR\n");
}

void HardFault_Handler(void)
{
	printf("In Hardfault handler\n");
	while(1);
}

void SVC_Handler(void)
{
	printf("In Hardfault handler\n");
}

void USART3_IRQHandler(void)
{
	printf("In USART3_IRQHandler\n");
}

void TIM2_IRQHandler(void)
{
	printf("In TIM2_IRQHandler\n");
	*pNVIC_ISPRBase |= (1 << IRQNO_I2C1);
	while(1);
}

void I2C1_EV_IRQHandler(void)
{
	printf("In I2C1_EV_IRQHandler\n");
}
