/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/* include driver/inc */
#include<stm32f446re.h>
#include<stm32f446re_gpio.h>
#include<stm32f446re_spi.h>
#include<stm32f446re_usart.h>
#include<stdint.h>
#include<string.h>

/* NOTE: *
 * Created driver/inc and driver/src folders and uncheck "Exclude resource from build" on folder driver.
 * Where to find above checkbox?
 * Click on driver folder -> right click properties -> c/c++ build
 * Above action will include driver folder in to build.
 * */

//extern initialise_monitor_handles();

/* Debounce delay:
 * Not properly recognized values:
 * 500, 5000, 50000
 * Some what good values
 * 500000 (observed some misses with this delay)
 * */
void delay(void)
{
	for (uint32_t i=0;i<500000;i++);
}

void toggle_led_with_pushpull(void)
{
	GPIO_Handle_t GpioLed;

	GpioLed.pGPIOx = GPIOA;
	GpioLed.GPIO_PinConfg.GPIO_PinNumber 		= GPIO_PIN_NO_5;
	GpioLed.GPIO_PinConfg.GPIO_PinMode 			= GPIO_MODE_OUT;
	GpioLed.GPIO_PinConfg.GPIO_PinSpeed 		= GPIO_SPEED_FAST;
	GpioLed.GPIO_PinConfg.GPIO_PinOPType 		= GPIO_OP_TYPE_PP;
	GpioLed.GPIO_PinConfg.GPIO_PinPuPdControl 	= GPIO_NO_PUPD;

	GPIOx_clk_control(GpioLed.pGPIOx, ENABLE);

	GPIOx_Init(&GpioLed);

	while(1) {
		GPIOx_ToggleOutputPin(GpioLed.pGPIOx, GpioLed.GPIO_PinConfg.GPIO_PinNumber);
		delay();
	}
}

void toggle_led_with_opendrian(void)
{
	GPIO_Handle_t GpioLed;

	GpioLed.pGPIOx = GPIOA;
	GpioLed.GPIO_PinConfg.GPIO_PinNumber 		= GPIO_PIN_NO_5;
	GpioLed.GPIO_PinConfg.GPIO_PinMode 			= GPIO_MODE_OUT;
	GpioLed.GPIO_PinConfg.GPIO_PinSpeed 		= GPIO_SPEED_FAST;
	GpioLed.GPIO_PinConfg.GPIO_PinOPType 		= GPIO_OP_TYPE_OD;
	GpioLed.GPIO_PinConfg.GPIO_PinPuPdControl 	= GPIO_PIN_PU;

	GPIOx_clk_control(GpioLed.pGPIOx, ENABLE);

	GPIOx_Init(&GpioLed);

	while(1) {
		GPIOx_ToggleOutputPin(GpioLed.pGPIOx, GpioLed.GPIO_PinConfg.GPIO_PinNumber);
		delay();
	}
}

void route_hsi_to_mco(void)
{
	/* for clear always use and with not operator.
	 * for set always use or operator
	 * */
	GPIO_Handle_t GpioMco;

	// configure HSI for MCO1 bit in CFGR ( 0 for HSI)
	RCC->CFGR &= ~(0x3 << 21);

	// configure MCO1 prescaler value (0x0 : no division)
	RCC->CFGR &= ~(0x7 << 23);

	GpioMco.pGPIOx = GPIOA;
	GpioMco.GPIO_PinConfg.GPIO_PinNumber 		= GPIO_PIN_NO_8;
	GpioMco.GPIO_PinConfg.GPIO_PinMode 			= GPIO_MODE_ALTFN;
	GpioMco.GPIO_PinConfg.GPIO_PinSpeed 		= GPIO_SPEED_FAST;
	GpioMco.GPIO_PinConfg.GPIO_PinOPType 		= GPIO_OP_TYPE_PP;
	GpioMco.GPIO_PinConfg.GPIO_PinPuPdControl 	= GPIO_PIN_PU;
	GpioMco.GPIO_PinConfg.GPIO_PinAltFunMode 	= GPIO_ALT_MODE_0;

	GPIOx_clk_control(GpioMco.pGPIOx, ENABLE);

	GPIOx_Init(&GpioMco);
}

void toggle_led_on_button_press(void)
{
	GPIO_Handle_t gpioLed;
	GPIO_Handle_t gpioBtn;

	gpioLed.pGPIOx = GPIOA;
	gpioLed.GPIO_PinConfg.GPIO_PinNumber 		= GPIO_PIN_NO_5;
	gpioLed.GPIO_PinConfg.GPIO_PinMode 			= GPIO_MODE_OUT;
	gpioLed.GPIO_PinConfg.GPIO_PinSpeed 		= GPIO_SPEED_FAST;
	gpioLed.GPIO_PinConfg.GPIO_PinOPType 		= GPIO_OP_TYPE_PP;
	gpioLed.GPIO_PinConfg.GPIO_PinPuPdControl 	= GPIO_NO_PUPD;
	GPIOx_clk_control(gpioLed.pGPIOx, ENABLE);
	GPIOx_Init(&gpioLed);

	gpioBtn.pGPIOx = GPIOC;
	gpioBtn.GPIO_PinConfg.GPIO_PinNumber 		= GPIO_PIN_NO_13;
	gpioBtn.GPIO_PinConfg.GPIO_PinMode 			= GPIO_MODE_IN;
	gpioBtn.GPIO_PinConfg.GPIO_PinSpeed 		= GPIO_SPEED_FAST;
	gpioBtn.GPIO_PinConfg.GPIO_PinPuPdControl 	= GPIO_PIN_PD;
	GPIOx_clk_control(gpioBtn.pGPIOx, ENABLE);
	GPIOx_Init(&gpioBtn);

	while(1) {
		if(!GPIOx_ReadFromInputPin(gpioBtn.pGPIOx, GPIO_PIN_NO_13)) {
			delay();
			GPIOx_ToggleOutputPin(gpioLed.pGPIOx, gpioLed.GPIO_PinConfg.GPIO_PinNumber);
		}
	}

}

void init_Blue_Button(void)
{
	GPIO_Handle_t gpioBtn;

	gpioBtn.pGPIOx = GPIOC;
	gpioBtn.GPIO_PinConfg.GPIO_PinNumber 		= GPIO_PIN_NO_13;
	gpioBtn.GPIO_PinConfg.GPIO_PinMode 			= GPIO_MODE_IN;
	gpioBtn.GPIO_PinConfg.GPIO_PinSpeed 		= GPIO_SPEED_FAST;
	gpioBtn.GPIO_PinConfg.GPIO_PinPuPdControl 	= GPIO_PIN_PD;
	GPIOx_clk_control(gpioBtn.pGPIOx, ENABLE);
	GPIOx_Init(&gpioBtn);

}

void interrupt_based_toggle_led_on_button_press(void)
{
	GPIO_Handle_t gpioLed;
	GPIO_Handle_t gpioBtn;

	memset(&gpioLed, 0, sizeof(gpioLed));
	memset(&gpioBtn, 0, sizeof(gpioBtn));

	gpioLed.pGPIOx = GPIOA;
	gpioLed.GPIO_PinConfg.GPIO_PinNumber 		= GPIO_PIN_NO_5;
	gpioLed.GPIO_PinConfg.GPIO_PinMode 			= GPIO_MODE_OUT;
	gpioLed.GPIO_PinConfg.GPIO_PinSpeed 		= GPIO_SPEED_FAST;
	gpioLed.GPIO_PinConfg.GPIO_PinOPType 		= GPIO_OP_TYPE_PP;
	gpioLed.GPIO_PinConfg.GPIO_PinPuPdControl 	= GPIO_NO_PUPD;
	GPIOx_clk_control(gpioLed.pGPIOx, ENABLE);
	GPIOx_Init(&gpioLed);

	gpioBtn.pGPIOx = GPIOC;
	gpioBtn.GPIO_PinConfg.GPIO_PinNumber 		= GPIO_PIN_NO_13;
	gpioBtn.GPIO_PinConfg.GPIO_PinMode 			= GPIO_MODE_IT_FT;
	gpioBtn.GPIO_PinConfg.GPIO_PinSpeed 		= GPIO_SPEED_FAST;
	gpioBtn.GPIO_PinConfg.GPIO_PinPuPdControl 	= GPIO_PIN_PD;
	GPIOx_clk_control(gpioBtn.pGPIOx, ENABLE);
	GPIOx_Init(&gpioBtn);

	//IRQ configuration
	GPIOx_IRQPriorityConfig(IRQ_NO_EXTI15_10, NVIC_IRQ_PRIORITY_15);
	GPIOx_IRQInterruptConfig(IRQ_NO_EXTI15_10, ENABLE);
}

/*
 * Application to test SPI_SendData API
 * Use SPI2, with below configurations
 * SPI2 - Master mode
 * SCLK = Max Possible
 * DFF= 0 and DFF = 1
 * GPIO PINS: FOR SPI2
 * --------------------
 * SPI2_SCK: 	PA9: AF5
 * SPI2_SCK: 	PB10: AF5
 * SPI2_SCK: 	PB13: AF5 [select]
 * SPI2_SCK:	PC7: AF5
 * SPI2_SCK:	PD3: AF5
 *
 * SPI2_NSS: 	PB4: AF7
 * SPI2_NSS: 	PB9: AF5
 * SPI2_NSS: 	PB12: AF5 [select]
 * SPI2_NSS:	PD1: AF7
 *
 * SPI2_MISO: 	PB14: AF5 [select]
 * SPI2_MISO:	PC2: AF5
 *
 * SPI2_MOSI: 	PB15: AF5 [select]
 * SPI2_MOSI:	PC3: AF5
 *
 * SPI2_MOS:	PC7: AF7
 *
 */

void SPI2_GPIOInits(void)
{
	GPIO_Handle_t SPI2Pins;

	memset(&SPI2Pins, 0, sizeof(SPI2Pins));
	SPI2Pins.pGPIOx = GPIOB;

	// SPI2_NSS
	SPI2Pins.GPIO_PinConfg.GPIO_PinMode = GPIO_MODE_ALTFN;
	SPI2Pins.GPIO_PinConfg.GPIO_PinAltFunMode = GPIO_ALT_MODE_5;
	SPI2Pins.GPIO_PinConfg.GPIO_PinNumber = GPIO_PIN_NO_12;
	SPI2Pins.GPIO_PinConfg.GPIO_PinSpeed = GPIO_SPEED_FAST;
	SPI2Pins.GPIO_PinConfg.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	SPI2Pins.GPIO_PinConfg.GPIO_PinPuPdControl = GPIO_NO_PUPD;

	GPIOx_clk_control(SPI2Pins.pGPIOx, ENABLE);
	GPIOx_Init(&SPI2Pins);

	//SPI2_SCK
	SPI2Pins.GPIO_PinConfg.GPIO_PinNumber = GPIO_PIN_NO_13;
	GPIOx_Init(&SPI2Pins);

	//SPI2_MISO
	SPI2Pins.GPIO_PinConfg.GPIO_PinNumber = GPIO_PIN_NO_14;
	GPIOx_Init(&SPI2Pins);

	//SPI2_MOSI
	SPI2Pins.GPIO_PinConfg.GPIO_PinNumber = GPIO_PIN_NO_15;
	GPIOx_Init(&SPI2Pins);

}

void SPI2_Init(void)
{
	SPI_Handle_t SPI2Handle;

	memset(&SPI2Handle, 0, sizeof(SPI2Handle));

	SPI2Handle.pSPIx = SPI2;
	SPI2Handle.SPIConfig.SPI_BusConfig = SPI_BUS_CONFIG_FULL_DUPLEX;
	SPI2Handle.SPIConfig.SPI_DeviceMode = SPI_DEVICE_MODE_MASTER;
	SPI2Handle.SPIConfig.SPI_DFF = SPI_DATA_FORMAT_8_BITS;
	SPI2Handle.SPIConfig.SPI_ClkSpeed = SPI_SCLK_SPEED_DIV2;
	SPI2Handle.SPIConfig.SPI_CPHA = SPI_CPHA_LOW;
	SPI2Handle.SPIConfig.SPI_CPOL = SPI_CPOL_LOW;
	//SPI2Handle.SPIConfig.SPI_SSM = SPI_SSM_DI;
	SPI2Handle.SPIConfig.SPI_SSM = SPI_SSM_EN;		// To test SPI without connecting to slave

	SPIx_clk_control(SPI2Handle.pSPIx, ENABLE);

	SPIx_Init(&SPI2Handle);
}

void spi2_test_by_sending(void)
{
	char* user_data = "Hello World";

	// pinmux
	SPI2_GPIOInits();

	// init spi2 periheral
	SPI2_Init();

	// this makes NSS signal internally high and avoids MODF error
	SPIx_SSI_config(SPI2, ENABLE);

	// enable spi peripheral
	SPIx_peripheral_control(SPI2, ENABLE);

	SPI_SendData(SPI2, (uint8_t*)user_data, strlen(user_data));
}

static void USART1_GPIO_Init()
{
	GPIO_Handle_t USART1Pins;

	memset(&USART1Pins, 0, sizeof(USART1Pins));
	USART1Pins.pGPIOx = GPIOA;

	USART1Pins.GPIO_PinConfg.GPIO_PinMode = GPIO_MODE_ALTFN;
	USART1Pins.GPIO_PinConfg.GPIO_PinAltFunMode = GPIO_ALT_MODE_7;
	USART1Pins.GPIO_PinConfg.GPIO_PinSpeed = GPIO_SPEED_FAST;
	USART1Pins.GPIO_PinConfg.GPIO_PinOPType = GPIO_OP_TYPE_PP;
	USART1Pins.GPIO_PinConfg.GPIO_PinPuPdControl = GPIO_PIN_PU;	//Activate the internal pull up resistor

	GPIOx_clk_control(USART1Pins.pGPIOx, ENABLE);

	// USART1 TX
	USART1Pins.GPIO_PinConfg.GPIO_PinNumber = GPIO_PIN_NO_9;
	GPIOx_Init(&USART1Pins);

	// USART1 RX
	USART1Pins.GPIO_PinConfg.GPIO_PinNumber = GPIO_PIN_NO_10;
	GPIOx_Init(&USART1Pins);

}

static USART_Handle_t usart1_hdl;

static void USART1_Init()
{
	usart1_hdl.pUSARTx = USART1;
	usart1_hdl.USART_Config.USART_Baud = USART_STD_BAUD_115200;
	usart1_hdl.USART_Config.USART_HWFlowControl = USART_HW_FLOW_CTRL_NONE;
	usart1_hdl.USART_Config.USART_Mode = USART_MODE_ONLY_TX;
	usart1_hdl.USART_Config.USART_NoofStopBits = USART_STOPBITS_1;
	usart1_hdl.USART_Config.USART_ParityControl = USART_PARITY_DISABLE;
	usart1_hdl.USART_Config.USART_WordLength = USART_WORDLEN_8BITS;

	USART_Init(&usart1_hdl);
}

static char *msg = "USART1 Testing with my driver\n\r";

static void usart1_test_by_sending(void)
{
	USART1_GPIO_Init();

	USART1_Init();

	USART_PeripheralControl(USART1, ENABLE);

	init_Blue_Button();

	while(1) {

		if(!GPIOx_ReadFromInputPin(GPIOC, GPIO_PIN_NO_13)) {

			delay();

			USART_SendData(&usart1_hdl, (uint8_t*)msg, strlen(msg));
		}
	}

}

int main(void)
{
	//route_hsi_to_mco();

	/* toggle without delay is running at 191.5kHz.
	 * On poweron HSI is source clock and runs at
	 * 16Mhz. The same clock is fed to AHB1 and Cortex without any
	 * prescalers, then where is additional clock?
	 * I used above function to measure HSI.
	 * */
	//toggle_led_with_pushpull();

	//toggle_led_with_opendrian();

	//toggle_led_on_button_press();

	//interrupt_based_toggle_led_on_button_press();

	//spi2_test_by_sending();

	//TODO I2C

	//USART
	usart1_test_by_sending();

	for(;;);
}

void EXTI15_10_IRQHandler(void)
{
	// if button does not detect properly due to debounce effect, then introduce some delay
	// here. But with out delay too I haven't seen any issue.
	// Handler for GPIOPortX Pin 13
	GPIO_IRQHandling(GPIO_PIN_NO_13);

	GPIOx_ToggleOutputPin(GPIOA, GPIO_PIN_NO_5);
}

void I2C1_EV_IRQHandler(void)
{
	//I2C_EV_IRQHandling(&I2CHandle);
}

void I2C1_ER_IRQHandler(void)
{
	//I2C_ER_IRQHandling(&I2CHandle);
}

/*void I2C_ApplicationEventCallback(I2C_Handle_t *pI2CHandle, uint8_t AppEv)
{
	switch(AppEv) {
	case I2C_EV_TX_CMPLT: printf("Tx is complete\n"); break;
	case I2C_EV_RX_CMPLT: printf("Rx is complete\n"); break;
	case I2C_ERROR_BERR: printf("Tx is complete\n"); break;
	case I2C_ERROR_ARLO:
	case I2C_ERROR_AF:
		//In master mode, ack failure happens when slave fails to send ack for the byte sent from the master.
		printf("Ack Failure\n");
		// slave gone bad or slave removed from bus, or slave do not want data
		I2C_CloseSendData(pI2CHandle);

		//generate the stop condition to release the bus
		I2C_Generate_Stop_condition(I2C1);

		//Hang in infinite loop
		while(1);
		break;
	case I2C_ERROR_OVR:
	case I2C_ERROR_TIMEOUT:
	}
}*/
